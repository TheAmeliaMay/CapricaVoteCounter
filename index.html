<!DOCTYPE html>
<html>
<head>
    <title>Caprica Election Calculator</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Election calculator for the fictional nation of Caprica.">

    <style>
        body {
            font-family: Arial;
            margin-left: 10%;
            margin-right: 10%;
        }

        h2 {
            text-decoration: underline;
        }
    </style>

    <script type="text/javascript">
        // What percentage of the vote a party needs to qualify for seats
        var threshold = 0.03; // Threshold for single parties
        var thr2 = 0.05; // Threshold for 2 parties in a vote sharing agreement
        var thr3 = 0.1; // Threshold for 3 or more parties in a vote sharing agreement

        // The number of seats to allocate via the national, party-list vote
        var natSeats = 30;

        // Elements
        var partyInput;
        var ballotInput;

        // Is this a by-election?
        var byElection = false;

        // The abbreviations for each party or vote sharing agreement
        var partyCodes = {};

        // Stores information about a ballot
        class Ballot {
            constructor(timestamp, votes) {
                this.timestamp = timestamp;
                this.votes = votes;
            }
        }

        // An array to contain every ballot
        var ballots = [];

        // Keep track of the results
        var results = {
            'regional': {},
            'partyList': {}
        };

        // Keep track of party data
        var partyData = {};

        // Keep track of every election title
        var elections = [];

        // Display the results on screen
        function displayResults(displayPL) {
            // Create a div to contain the elements
            var div = document.createElement('div');
            div.id = 'results';

            // Display the regional results first
            var rh2 = document.createElement('h2');
            rh2.innerText = 'Regional Results';
            div.appendChild(rh2);

            // Show the results in each region
            var regResults = Object.entries(results.regional);
            for (let i = 0; i < regResults.length; i++) {
                var region = regResults[i];

                // Show the name of the region
                var regHeader = document.createElement('h3');
                regHeader.innerText = region[0];
                div.appendChild(regHeader);

                // Show the winner
                var winnerPar = document.createElement('p');
                winnerPar.innerHTML = `<b>Winner:</b> ${region[1].winner[0]}`;
                div.appendChild(winnerPar);

                // Create a details element to hold the full results in
                var regDetails = document.createElement('details');

                // Add a summary to the details
                var regSumm = document.createElement('summary');
                regSumm.innerText = 'Full results...';
                regDetails.appendChild(regSumm);

                // Iterate through each round
                for (let r = 0; r < region[1].rounds.length; r++) {
                    var round = region[1].rounds[r];

                    // Display the round
                    var roundHeader = document.createElement('h4');
                    roundHeader.innerText = `Round ${r + 1}`;
                    regDetails.appendChild(roundHeader);

                    // Iterate through each candidate
                    var entries = Object.entries(round);
                    for (let c = 0; c < entries.length; c++) {
                        var candidate = entries[c];

                        // Create a paragraph to display the text
                        var candPar = document.createElement('p');
                        candPar.innerText = `${candidate[0]}: ${candidate[1]}`;
                        regDetails.appendChild(candPar);
                    }
                }

                // Add the details to the div
                div.appendChild(regDetails);
                
                // Add a break after each region
                var br = document.createElement('br');
                div.appendChild(br);
            }

            // Display the party-list results
            if (displayPL) {
                var ph2 = document.createElement('h2');
                ph2.innerText = 'Party-list Results';
                div.appendChild(ph2);

                // Show the results for each party
                var parties = Object.entries(results.partyList);

                for (let j = 0; j < parties.length; j++) {
                    var party = parties[j];
                    var p = document.createElement('p');
                    p.innerHTML = `<b>${party[0]}:</b> ${party[1]} seats`;
                    div.appendChild(p);
                }
            }

            // Create a details element to show the full party-list results in
            var plDetails = document.createElement('details');

            // Add a summary to the details
            var plSumm = document.createElement('summary');
            plSumm.innerText = 'Full results...'
            plDetails.appendChild(plSumm);

            // Show the 1st round results
            var firstHeading = document.createElement('h4');
            firstHeading.innerText = 'Round 1';
            plDetails.appendChild(firstHeading);

            // Iterate over each party in the 1st round of the party data
            var firstParties = Object.entries(partyData['votes1st']);
            for (let i = 0; i < firstParties.length; i++) {
                // Show the number of votes that party got
                var party = firstParties[i];
                var fpp = document.createElement('p');
                fpp.innerHTML = `${party[0]}: ${party[1]}`;
                plDetails.appendChild(fpp);
            }

            // Show the 2nd round results
            var secondHeading = document.createElement('h4');
            secondHeading.innerText = 'Round 2';
            plDetails.appendChild(secondHeading);

            // Iterate over each party in the 2nd round of the party data
            var secondParties = Object.entries(partyData['votes2nd']);
            for (let i = 0; i < secondParties.length; i++) {
                // Show the number of votes that party got
                var party = secondParties[i];
                var spp = document.createElement('p');
                spp.innerHTML = `${party[0]}: ${party[1]}`;
                plDetails.appendChild(spp);
            }

            // Add the details to the div
            div.appendChild(plDetails);

            // Add the div to the page
            document.body.appendChild(div);

            console.log(results);
            console.log(partyData);
        }

        // Calculate the regional elections
        function calcRegion() {
            // Iterate through every region to calculate the results
            for (let i = 0; i < elections.length - 1 * !byElection; i++) {
                // Get the name of the region
                var region = elections[i];

                // Keep track of each round
                var rounds = [];

                // Keep track of the total votes for each round
                var totals = [];

                // What the current round is
                var currentRound = 0;

                // Keep track of eliminated candidates
                var eliminated = [];

                // Who has won (no one by default)
                var winner = null;

                // Loop until someone wins
                while (winner === null) {
                    // Add a new round to the array
                    rounds.push({});

                    // Add a new total for the round
                    totals.push(0);

                    // Iterate through each ballot
                    for (let b = 0; b < ballots.length; b++) {
                        var ballot = ballots[b];

                        // Skip the ballot if they didn't vote in that region
                        if (ballot.votes[region] === undefined) {
                            continue;
                        }
                        
                        // Get the preferences for the region being calculated
                        var preferences = Object.values(ballot.votes[region]);

                        // Iterate through each preference
                        for (let p = 0; p < preferences.length; p++) {
                            var pref = preferences[p];

                            // Vote for the first candidate who hasn't been eliminated yet
                            // Exclude candidates who did not receive at least 1 vote in the first round (as they won't get eliminated)
                            // If all preferences have been eliminated, the ballot will be exhausted and ignored
                            if (eliminated.indexOf(pref) == -1 && (currentRound == 0 || Object.keys(rounds[0]).indexOf(pref) != -1)) {
                                if (Object.hasOwn(rounds[currentRound], pref)) {
                                    // Add one vote to the candidate
                                    rounds[currentRound][pref]++;
                                } else {
                                    // Add the candidate to the round with 1 votes
                                    rounds[currentRound][pref] = 1;
                                }

                                // Add one vote to the total
                                totals[currentRound]++;

                                break;
                            }
                        }
                    }

                    // Get a list of candidates in the current round
                    var candidates = Object.entries(rounds[currentRound]);

                    // Check for a tie (every candidate has the same vote total)
                    var tieValue = candidates[0][1];
                    var tied = [];
                    for (let c = 0; c < candidates.length; c++) {
                        if (candidates[c][1] == tieValue) {
                            tied.push(candidates[c][0]);
                        } else {
                            // There's not a tie, so clear the array
                            tied = [];
                            break;
                        }
                    }

                    // If there's a tie, set the list of tied candidates as the winner
                    if (tied.length > 0) {
                        winner = tied;
                    }

                    // Check if a candidate has won a majority yet
                    for (let c = 0; c < candidates.length; c++) {
                        var cand = candidates[c];

                        if (cand[1] > totals[currentRound] / 2) {
                            // They won a majority of the vote, so they're the winner
                            winner = [cand[0]];
                        }
                    }

                    // If there's not a winner yet, find the candidate with the least votes and eliminate them
                    var leastNum = Infinity;
                    var leastCand = [];

                    for (let c = 0; c < candidates.length; c++) {
                        var cand = candidates[c];

                        if (cand[1] < leastNum) {
                            // They have less votes than all the previous candidates
                            leastNum = cand[1];
                            leastCand = [cand[0]];
                        } else if (cand[1] == leastNum) {
                            // There's multiple candidates with the least amount of votes so far
                            leastCand.push(cand[0]);
                        }
                    }

                    if (leastCand.length == candidates.length) {
                        // There's a tie, because none of the candidates can be eliminated
                        winner = leastCand;
                    } else {
                        // Eliminate the candidate(s)
                        for (let c = 0; c < leastCand.length; c++) {
                            eliminated.push(leastCand[c]);
                        }
                    }
                    
                    // Disable first
                    first = false;

                    // Increase the current round number
                    currentRound++;
                }

                // Break ties
                if (winner.length > 1) {
                    // Check who had the most first preference votes
                    var highest1p = [];
                    var h1pv = 0;

                    // Interate through each of the tied candidates
                    for (let w = 0; w < winner.length; w++) {
                        // Get the number of 1st preference votes
                        var first = rounds[0][winner[w]];

                        // Check if it's higher than the current highest
                        if (first > h1pv) {
                            // Set the highest to this candidate
                            highest1p = [winner[w]];
                        } else if (first == h1pv) {
                            // If they had the same number of first preference votes, push it to the list
                            highest1p.push(winner[w]);
                        }
                    }

                    if (highest1p.length > 1) {
                        // If there's stil a tie, choose a candidate at random
                        winner = highest1p[Math.floor(Math.random() * highest1p.length)];
                    } else {
                        // Set the candidate with the most 1st preference votes as the winner
                        winner = highest1p;
                    }
                }

                // Save the results
                results.regional[region] = {
                    'winner': winner,
                    'rounds': rounds
                };
            }
        }

        // Calculate the party-list results (the last election in the series)
        function calcParty() {
            // Keep track of information for parties
            partyData = {
                'votes1st': {}, // The number of votes in the 1st round
                'votes2nd': {}, // The number of votes in the 2nd round
                'seats': {}, // The total number of seats each party won
                'additional': {}, // The number of additional seats allocated via the party-list vote
                'timeSinceWon': {} // How many rounds of apportionment it's been since each party last won a seat
            };

            // Get the number of seats won by each party in the regional elections
            var regResults = Object.values(results.regional);
            for (let i = 0; i < regResults.length; i++) {
                var region = regResults[i];

                // We can't calculate the results if there's a tie
                if (region.winner.length > 1) {
                    return false;
                }

                // Get the party code from the winner's name in parentheses
                var pCode = region.winner[0].match(/(\(.*\)$)/)[0];
                pCode = pCode.substring(1, pCode.length - 1);

                // Figure out which party they're a member of
                var party;
                var pCodes = Object.keys(partyCodes);
                for (let c = 0; c < pCodes.length; c++) {
                    if (partyCodes[pCodes[c]].indexOf(pCode) > -1) {
                        party = pCodes[c];
                    }
                }

                // No party is found
                if (party === null) {
                    alert(`No party found for ${region.winner[0]}!`);
                    return false;
                }

                // Count them as a seat for their party
                if (Object.hasOwn(partyData.seats, party)) {
                    // Add 1 to the seat count
                    partyData.seats[party]++;
                } else {
                    // Add a new party with 1 seat
                    partyData.seats[party] = 1;
                }
            }

            // Keep track of the total number of votes in both rounds
            var total1 = 0;
            var total2 = 0;

            // Count the total number of votes for every party for the 1st preference
            for (let b = 0; b < ballots.length; b++) {
                var ballot = ballots[b];
                
                // Get the first preference vote
                var preferences = Object.values(ballot.votes);

                // Don't count the vote (they didn't vote in the party-list election)
                if (preferences[preferences.length - 1] === undefined) {
                    continue;
                }

                var pref = preferences[preferences.length - 1][1];

                // Don't count the vote (they didn't vote in the party-list election)
                if (pref === undefined) {
                    continue;
                }

                if (pref !== null) {
                    if (Object.hasOwn(partyData.votes1st, pref)) {
                        // Add one vote for the party
                        partyData.votes1st[pref]++;
                    } else {
                        // Add a new entry with 1 vote
                        partyData.votes1st[pref] = 1;
                    }

                    // Add 1 to the total
                    total1++;
                }
            }

            // Qualify parties that got more votes than the threshold
            var qualifying = [];
            var parties = Object.entries(partyData.votes1st);

            for (let p = 0; p < parties.length; p++) {
                var party = parties[p];

                // Get the threshold based on the number of parties it represents
                var pCode = partyCodes[party[0]];
                var thr = threshold; // Default threshold for single parties

                // Skip it if the code is undefined)
                if (pCode === undefined) {
                    continue;
                }

                if (pCode.length == 2) {
                    thr = thr2; // Threshold for 2 parties in a VSA
                } else if (pCode.length > 2) {
                    thr = thr3; // Threshold for 3+ parties in a VSA
                }

                // Qualify the party if it got more votes than the threshold
                if (party[1] / total1 > thr) {
                    qualifying.push(party[0]);
                }
            }

            // Count the 2nd round of votes
            for (let b = 0; b < ballots.length; b++) {
                var ballot = ballots[b];

                // Get the voter's party-list preferences
                var preferences = Object.values(ballot.votes);
                preferences = preferences[preferences.length - 1];

                // Don't count the vote (they didn't vote in the party-list election)
                if (preferences === undefined) {
                    continue;
                }

                // Get which preference to vote for
                var pref;
                if (qualifying.indexOf(preferences[1]) > -1) {
                    // Use the 1st preference if they qualify
                    pref = preferences[1];
                } else {
                    // Use the 2nd preference if they don't
                    pref = preferences[2];
                }

                // Don't count the vote (they didn't vote in the party-list election)
                if (pref === undefined) {
                    continue;
                }

                // Skip if undefined
                if (pref === undefined) {
                    continue;
                }

                if (pref !== null) {
                    if (Object.hasOwn(partyData.votes2nd, pref)) {
                        // Add one vote for the party
                        partyData.votes2nd[pref]++;
                    } else {
                        // Add a new entry with 1 vote
                        partyData.votes2nd[pref] = 1;
                    }

                    // Add 1 to the total
                    total2++;
                }
            }

            // Set time since won to 0 for every party
            for (let q = 0; q < qualifying.length; q++) {
                partyData.timeSinceWon[qualifying[q]] = 0;
            }

            // Allocate the party-list seats until none are left
            var totalSeats = 0;
            while (totalSeats < natSeats) {
                // Calculate the quotient for every party and find the highest
                var highestQ = 0;
                var highestP = [];

                for (let i = 0; i < qualifying.length; i++) {
                    var party = qualifying[i];

                    // Get the number of seats the party has
                    var seats = 0;

                    if (Object.hasOwn(partyData.seats, party)) {
                        // Get the number of seats the party has already won
                        seats = partyData.seats[party];
                    } else {
                        // Set the number of seats to 0
                        partyData.seats[party] = 0;
                    }

                    // Calculate the quotient
                    var quotient = partyData.votes2nd[party] / (seats * 1.5 + 1);

                    // Check if it's higher
                    if (quotient > highestQ) {
                        // Save it as the party with the highest quotient
                        highestQ = quotient;
                        highestP = [party];
                    } else if (quotient == highestQ) {
                        // It's a tie, so push the party to the array
                        highestP.push(party);
                    }
                }

                if (highestP.length == 1) {
                    // Give the party with the highest quotient an extra seat
                    partyData.seats[highestP[0]]++;

                    if (Object.hasOwn(partyData.additional, highestP[0])) {
                        partyData.additional[highestP[0]]++;
                    } else {
                        partyData.additional[highestP[0]] = 1;
                    }

                    // Add 1 to the total
                    totalSeats++;

                    // Reset the time since won counter
                    partyData.timeSinceWon[highestP[0]] = 0;
                } else {
                    // Get how many seats are left
                    var seatsLeft = natSeats - totalSeats;

                    // If tied, check if there's enough seats left to give one to all of them
                    if (seatsLeft >= highestP.length) {
                        // Give them all a seat
                        for (let i = 0; i < highestP.length; i++) {
                            var party = highestP[i];
                            partyData.seats[party]++;

                            if (Object.hasOwn(partyData.additional, party)) {
                                partyData.additional[party]++;
                            } else {
                                partyData.additional[party] = 1;
                            }

                            // Add 1 to the total
                            totalSeats++;

                            // Reset the time since won counter
                            partyData.timeSinceWon[party] = 0;
                        }
                    } else {
                        // There's a true tie, so check which party hasn't won a seat for the longest time
                        // Loop over the remaining seats
                        while (seatsLeft > 0) {
                            var longest = 0;
                            var longestP = [];

                            // Loop over each tied party
                            for (let p = 0; p < highestP.length; p++) {
                                var party = highestP[p];

                                // Get how long it's been since that party won a seat
                                var time = partyData.timeSinceWon[party];

                                // Check if it's longer than the current longest
                                if (time > longest) {
                                    longest = time;
                                    longestP = [party];
                                } else {
                                    // There's a tie, so append it
                                    longestP.push(party);
                                }
                            }

                            // Give the seat to the party unless there's a tie
                            if (longestP.length == 1) {
                                partyData.seats[longestP[0]]++;

                                if (Object.hasOwn(partyData.additional, longestP[0])) {
                                    partyData.additional[longestP[0]]++;
                                } else {
                                    partyData.additional[longestP[0]] = 1;
                                }

                                // Add 1 to the total
                                totalSeats++;

                                // Subtract 1 from seats left
                                seatsLeft--;

                                // Reset the time since won counter
                                partyData.timeSinceWon[longestP[0]] = 0;
                            } else {
                                // If there's a tie again, check if there's enough seats left to give them all seats
                                if (seatsLeft >= longestP.length) {
                                    // Give every party a seat
                                    for (let i = 0; i < longestP.length; i++) {
                                        var party = longestP[i];

                                        partyData.seats[party]++;

                                        if (Object.hasOwn(partyData.additional, party)) {
                                            partyData.additional[party]++;
                                        } else {
                                            partyData.additional[party] = 1;
                                        }

                                        // Add 1 to the total
                                        totalSeats++;

                                        // Subtract 1 from seats left
                                        seatsLeft--;

                                        // Reset the time since won counter
                                        partyData.timeSinceWon[party] = 0;
                                    }
                                } else {
                                    // There's not enough left, so there's a true tie
                                    // Choose a party at random until there's no seats left
                                    // And make sure not to chose the same party twice if there's multiple
                                    var lpCopy = longestP.slice();
                                    for (let i = 0; i < seatsLeft; i++) {
                                        // Get a party at random and remove it from the array
                                        var party = lpCopy.splice(Math.floor(Math.random() * lpCopy.length), 1);

                                        // Give that party a seat
                                        partyData.seats[party]++;

                                        if (Object.hasOwn(partyData.additional, party)) {
                                            partyData.additional[party]++;
                                        } else {
                                            partyData.additional[party] = 1;
                                        }

                                        // Add 1 to the total
                                        totalSeats++;
                                    }

                                    seatsLeft = 0;
                                }
                            }
                        }
                    }
                }
            }

            // Save the results as the additional number of seats
            results.partyList = partyData.additional;

            // Return true if it's successful
            return true;
        }

        // Convert each line to a ballot object and add it to the array
        function readBallots(lines) {
            // Get the header from the first row
            var header = lines[0];

            // Categorize columns based on the election title and candidate name
            var columnInfo = [];

            for (let i = 1; i < header.length; i++) {
                // Get the name of the election (outside the brackets)
                var election = header[i].match(/(^.*(?= \[))/)[0].replace(/^"/, "");

                // Get the name of the candidate (inside the brackets)
                var candidate = header[i].match(/(\[.*\]"?$)/)[0].replace(/"$/, "");
                candidate = candidate.substring(1, candidate.length - 1);

                // Add the information to the array
                columnInfo.push({
                    'election': election,
                    'candidate': candidate
                });

                // Keep track of the title for each election
                if (elections.indexOf(election) == -1) {
                    elections.push(election);
                }
            }

            // Iterate through each ballot
            for (let i = 1; i < lines.length; i++) {
                var line = lines[i];

                // Add every race to an object
                var races = {};
                for (let c = 1; c < line.length; c++) {
                    // Get the cell
                    var cell = line[c];

                    // Get the column information
                    var col = columnInfo[c - 1];

                    // Add the election if it doesn't exist
                    if (!Object.hasOwn(races, col.election)) {
                        races[col.election] = {};
                    }

                    // Get the election
                    var election = races[col.election];

                    // Check if the preference is a number, like "1", or something like "1st"
                    var pref;
                    if (isNaN(cell)) {
                        // Get the preference number by removing the last two letters
                        pref = cell.substring(0, cell.length - 2);
                    } else {
                        // It's a number, so convert it
                        pref = Number(cell);
                    }

                    // Add the preference if it's not blank
                    if (pref !== undefined && pref > 0) {
                        election[pref] = col.candidate;
                    }
                }

                // Create the ballot
                var ballot = new Ballot(line[0], races);

                // Add it to the array
                ballots.push(ballot);
            }

            // Calculate and display the results
            calcRegion();

            // Don't calculate party results for a by-election
            if (byElection) {
                displayResults(false);
            } else {
                displayResults(calcParty());
            }
        }

        // Read the ballot input CSV file
        function readBallotFile() {
            // Create a new file reader
            var reader = new FileReader();

            reader.addEventListener('load', function() {
                // Convert the text to an array of lines
                var lines = reader.result.split('\r\n');
                
                // Create a new array to store split lines in
                var linesNew = [];

                // Split lines into arrays of cells
                for (var i = 0; i < lines.length; i++) {
                    // Will match commas, unless they're inside quotation marks, and retains empty cells
                    var cells = lines[i].split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/g);
                    linesNew.push(cells);
                }

                // Read the ballots
                readBallots(linesNew);
            });

            reader.readAsText(ballotInput.files[0]);
        }

        // Read the party input CSV file
        function readPartyFile() {
            // Create a new file reader
            var reader = new FileReader();

            reader.addEventListener('load', function() {
                // Convert the text to an array of lines
                var lines = reader.result.split('\r\n');
                
                // Create a new array to store split lines in
                var linesNew = [];

                // Iterate over each line
                for (var i = 0; i < lines.length; i++) {
                    // Split the line into cells
                    var cells = lines[i].split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/g);

                    // Information about the party
                    var partyName;
                    var partyAbbr = [];
                    
                    // Iterate over each cell
                    for (var c = 0; c < cells.length; c++) {
                        if (c == 0) {
                            // The first cell is the full name (if VSA, includes all parties)
                            partyName = cells[c].replace(/^"/,"").replace(/"$/,"");
                        } else {
                            // All other cells are abbreviations
                            // Don't push empty cells
                            if (cells[c].length > 0) {
                                partyAbbr.push(cells[c]);
                            }
                        }
                    }

                    // Save the list of abbreviations
                    partyCodes[partyName] = partyAbbr;
                }

                // Read the ballot file now that it's loaded
                readBallotFile();
            });

            reader.readAsText(partyInput.files[0]);
        }

        // Called when the user clicks on the calculate button
        function calculate() {
            // Check if it's a by-election
            byElection = document.getElementById('byElection').checked;

            if (byElection) {
                // Make sure the ballot file has been uploaded
                if (ballotInput.files.length < 1) {
                    // Warn the user and abort
                    alert('Please upload the ballot file!');
                    return;
                }
            } else {
                // Make sure both CSVs have been uploaded
                if (partyInput.files.length < 1 || ballotInput.files.length < 1) {
                    // Warn the user and abort
                    alert('Please upload both files!');
                    return;
                }
            }

            // If it's already been calculated once, reset it first
            var div = document.getElementById('results');
            if (div !== null) {
                // Delete the results div
                div.remove();

                // Reset variables
                partyCodes = {};
                ballots = [];
                results = {
                    'regional': {},
                    'partyList': {}
                };
                elections = [];
            }

            if (byElection) {
                // Only read the ballot file if it's a by-election
                readBallotFile();
            } else {
                // Read the party file first (it'll read the ballot file once it's done)
                readPartyFile();
            }
        }

        window.onload = function() {
            // Get the party and ballot input elements
            partyInput = document.getElementById('partyInput');
            ballotInput = document.getElementById('ballotInput');
        }
    </script>
</head>
<body>
    <h1>Caprica Election Calculator</h1>
    <label for="partyInput">Parties: </label>
    <input type="file" name="file" id="partyInput" accept=".csv"><br><br>
    <label for="ballotInput">Ballots: </label>
    <input type="file" name="file" id="ballotInput" accept=".csv"><br><br>
    <input type="checkbox" name="byElection" id="byElection">
    <label for="byElection">By-election (if checked, party file is not needed)</label><br><br>
    <button onclick="calculate()">Calculate</button>
</body>
</html>